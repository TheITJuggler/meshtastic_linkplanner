<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meshtastic Coverage Estimator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        #map {
            height: 100%;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            width: 200px;
        }

        #color-bar-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            width: 200px;
            text-align: center;
        }

        .color-bar {
            width: 100%;
            height: 20px;
            background: linear-gradient(to right, red, orange, yellow, green, blue, purple);
        }

        input[type="text"],
        button {
            display: block;
            margin-bottom: 10px;
            width: 100%;
            padding: 5px;
            box-sizing: border-box;
        }

        #about-link {
            display: block;
            margin-top: 10px;
            text-align: right;
        }

 dialog {
    width: 400px;
    max-width: 100%;
    padding: 20px;
    border: none;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    text-align: left;
}

        dialog button {
        width: 60px; /* Or set a specific width like 100px */
        padding: 5px 10px; /* Adjust padding to control the button size */
        display: inline-block;
        text-align: center;
        margin-top: 10px;
    }
    </style>
</head>

<body>
    <div id="map"></div>

    <div class="controls">
        <h3>Meshtastic Coverage Estimator</h3>
        <p>ITM / Longely-Rice model for estimating the range of your meshtastic radio.</p>
        <p>Click on the map to select a location, then click run model. The colored tiles are where your radio signal can reach.</p>

        <label for="height">Height (m):</label>
        <input type="text" id="height" value="1.0">

        <label for="gain">Antenna gain (dB):</label>
        <input type="text" id="gain" value="2.0">

        <label for="lat">Latitude (deg):</label>
        <input type="text" id="lat" value="51.000000">

        <label for="lng">Longitude (deg):</label>
        <input type="text" id="lng" value="-114.000000">

        <label for="region">Region:</label>
        <select id="region">
            <option value="US">US</option>
            <option value="EU_868">EU_868</option>
        </select>
        <p></p>
        <button onclick="predict()">Run Model</button>

        <!-- About link -->
        <a href="#" id="about-link" onclick="openAboutDialog()">About</a>
    </div>

    <!-- Color bar for RSSI -->
    <div id="color-bar-container">
        <p>Predicted RSSI (dB)</p>
        <div class="color-bar" id="color-bar"></div>
        <div style="display: flex; justify-content: space-between;">
            <span id="min-rssi">-140</span>
            <span id="max-rssi">-90</span>
        </div>
    </div>

    <!-- About dialog -->
    <dialog id="about-dialog">
    <h3>About</h3>
    <p>
        This tool calculates the ITM / Longley-Rice radio propagation model for Meshtastic LoRa radios
        (see <a href="https://www.meshtastic.org" target="_blank">www.meshtastic.org</a>). It is not affiliated
        with the Meshtastic project.
    </p>
    <p>
        An effort has been made to choose model parameters which are realistic for these devices. However, the model
        does not account for urban buildings or higher-order effects such as reflections from water, structures, or signal degradation by precipitation.
        The results on this page should be considered estimates and should not be used for safety-critical applications
        or emergency preparation.
    </p>

    <h3>Acknowledgements</h3>
    <p>
        The signal processing engine is based on work by the author of the
        <a href="https://github.com/JayKickliter/geoprop-py" target="_blank">geoprop-py</a> repository.
    </p>
    <p>
        This webpage uses the <a href="https://leafletjs.com" target="_blank">Leaflet</a> library.
    </p>
    <p>
        Terrain data is sourced from NASA's Shuttle Radar Topography Mission
        (<a href="https://www.earthdata.nasa.gov/sensors/srtm" target="_blank">SRTM</a>).
    </p>
    <p>
        The required experimental data was gathered using hardware and software designs from
        <a href="https://www.meshtastic.org" target="_blank">www.meshtastic.org</a>.
    </p>
        <button onclick="closeAboutDialog()">Close</button>
    </dialog>

    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.8.2/dist/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3.0.0/dist/d3-scale-chromatic.min.js"></script>

    <script>
        var currentMarker = null;

        var map = L.map('map').setView([51, -114], 10);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        map.on('click', function (e) {
            document.getElementById('lat').value = e.latlng.lat.toFixed(6);
            document.getElementById('lng').value = e.latlng.lng.toFixed(6);

            if (currentMarker) {
                map.removeLayer(currentMarker);
            }

            currentMarker = L.marker(e.latlng).addTo(map);
        });

        async function predict() {
            const runButton = document.querySelector('button');
            runButton.textContent = 'Running Model...';
            runButton.disabled = true;

            var lat = parseFloat(document.getElementById('lat').value);
            var lon = parseFloat(document.getElementById('lng').value);
            var txh = parseFloat(document.getElementById("height").value);
            var gain = parseFloat(document.getElementById("gain").value);
            var region = document.getElementById("region").value;

            var postData = {
                "lat": lat,
                "lon": lon,
                "txh": txh,
                "rxh": 1.0,
                "tx_gain": gain,
                "rx_gain": 1.0,
                "region": region,
                "resolution": 8
            };

            try {
                const response = await fetch('http://127.0.0.1:8086/predict', {
                    method: 'POST',
                    headers: {
                        'x-api-key': 'large4catsmeshtastic',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(postData)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const geojson = await response.json();
                plotH3Tiles(geojson);

            } catch (error) {
                console.error('Error during prediction:', error);
            } finally {
                runButton.textContent = 'Run Model';
                runButton.disabled = false;
            }
        }

        function plotH3Tiles(geojson) {
            if (window.h3LayerGroup) {
                map.removeLayer(window.h3LayerGroup);
            }

            const h3LayerGroup = L.layerGroup();
            const rssiThreshold = -130;

            geojson.features.forEach(feature => {
                const modelRssi = feature.properties.model_rssi;

                if (modelRssi > rssiThreshold) {
                    const hexBoundary = feature.geometry.coordinates[0].map(coord => [coord[1], coord[0]]);

                    const color = getColorForRssi(modelRssi);

                    const polygon = L.polygon(hexBoundary, {
                        color: color,
                        fillOpacity: 0.5
                    });

                    polygon.bindTooltip(`${modelRssi.toFixed(2)} dB`, {
                        permanent: false,
                        direction: "center"
                    });

                    h3LayerGroup.addLayer(polygon);
                }
            });

            h3LayerGroup.addTo(map);
            window.h3LayerGroup = h3LayerGroup;
        }

        function getColorForRssi(rssi) {
            const minRssi = -140;
            const maxRssi = -90;
            const normalized = (rssi - minRssi) / (maxRssi - minRssi);
            return d3.scaleSequential(d3.interpolatePlasma)(normalized);
        }

        function updateColorBar() {
            const colorBar = document.getElementById('color-bar');
            let gradientStops = [];
            const numSteps = 64;

            for (let i = 0; i <= numSteps; i++) {
                const normalized = i / numSteps;
                const color = d3.scaleSequential(d3.interpolatePlasma)(normalized);
                gradientStops.push(`${color} ${(i / numSteps) * 100}%`);
            }

            const gradient = `linear-gradient(to right, ${gradientStops.join(', ')})`;
            colorBar.style.background = gradient;
        }

        updateColorBar();

        // About dialog functions
        function openAboutDialog() {
            document.getElementById('about-dialog').showModal();
        }

        function closeAboutDialog() {
            document.getElementById('about-dialog').close();
        }
    </script>
</body>

</html>
